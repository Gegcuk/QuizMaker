package uk.gegc.quizmaker.features.quiz.application.generation.impl;

import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import uk.gegc.quizmaker.features.category.domain.model.Category;
import uk.gegc.quizmaker.features.category.domain.repository.CategoryRepository;
import uk.gegc.quizmaker.features.question.domain.model.Difficulty;
import uk.gegc.quizmaker.features.question.domain.model.Question;
import uk.gegc.quizmaker.features.quiz.api.dto.GenerateQuizFromDocumentRequest;
import uk.gegc.quizmaker.features.quiz.application.generation.QuizAssemblyService;
import uk.gegc.quizmaker.features.quiz.application.validation.QuizPublishValidator;
import uk.gegc.quizmaker.features.quiz.domain.model.Quiz;
import uk.gegc.quizmaker.features.quiz.domain.model.QuizStatus;
import uk.gegc.quizmaker.features.quiz.domain.model.Visibility;
import uk.gegc.quizmaker.features.quiz.domain.repository.QuizRepository;
import uk.gegc.quizmaker.features.tag.domain.model.Tag;
import uk.gegc.quizmaker.features.tag.domain.repository.TagRepository;
import uk.gegc.quizmaker.features.user.domain.model.User;

import java.util.*;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class QuizAssemblyServiceImpl implements QuizAssemblyService {

    private static final int QUIZ_TITLE_MAX_LENGTH = 100;

    private final QuizRepository quizRepository;
    private final CategoryRepository categoryRepository;
    private final TagRepository tagRepository;

    @Override
    public Category getOrCreateAICategory() {
        return categoryRepository.findByName("AI Generated")
                .orElseGet(() -> categoryRepository.findByName("General")
                        .orElseGet(() -> {
                            Category aiCategory = new Category();
                            aiCategory.setName("AI Generated");
                            aiCategory.setDescription("Quizzes automatically generated by AI");
                            return categoryRepository.save(aiCategory);
                        }));
    }

    @Override
    public Set<Tag> resolveTags(GenerateQuizFromDocumentRequest request) {
        if (request.tagIds() == null) {
            return new HashSet<>();
        }

        return request.tagIds().stream()
                .map(tagRepository::findById)
                .flatMap(Optional::stream)
                .collect(Collectors.toSet());
    }

    @Override
    @Transactional
    public Quiz createChunkQuiz(User user,
                                List<Question> questions,
                                int chunkIndex,
                                GenerateQuizFromDocumentRequest request,
                                Category category,
                                Set<Tag> tags,
                                UUID documentId) {
        String chunkTitle = generateChunkTitle(chunkIndex, questions);
        String baseTitle = String.format("Quiz: %s", chunkTitle);
        String quizTitle = ensureUniqueTitle(user, baseTitle);
        String quizDescription = String.format("Quiz covering %s from the document", chunkTitle);

        int estimatedTimeMinutes = Math.max(QuizPublishValidator.MINIMUM_ESTIMATED_TIME_MINUTES,
                (int) Math.ceil(questions.size() * 1.5));

        Quiz quiz = new Quiz();
        quiz.setTitle(quizTitle);
        quiz.setDescription(quizDescription);
        quiz.setCreator(user);
        quiz.setCategory(category);
        quiz.setTags(tags);
        quiz.setStatus(QuizStatus.PUBLISHED);
        quiz.setVisibility(Visibility.PRIVATE);
        quiz.setEstimatedTime(estimatedTimeMinutes);
        quiz.setQuestions(new HashSet<>(questions));
        quiz.setIsTimerEnabled(false);
        quiz.setIsRepetitionEnabled(false);
        quiz.setDifficulty(request.difficulty());

        return quizRepository.save(quiz);
    }

    @Override
    @Transactional
    public Quiz createConsolidatedQuiz(User user,
                                       List<Question> allQuestions,
                                       GenerateQuizFromDocumentRequest request,
                                       Category category,
                                       Set<Tag> tags,
                                       UUID documentId,
                                       int chunkCount) {
        String requestedTitle = request.quizTitle() != null ? request.quizTitle() : "Complete Document Quiz";
        String quizTitle = ensureUniqueTitle(user, requestedTitle);
        String quizDescription = request.quizDescription() != null ? request.quizDescription() :
                String.format("Comprehensive quiz covering all %d sections of the document", chunkCount);

        int estimatedTimeMinutes = Math.max(QuizPublishValidator.MINIMUM_ESTIMATED_TIME_MINUTES,
                (int) Math.ceil(allQuestions.size() * 1.5));

        Quiz quiz = new Quiz();
        quiz.setTitle(quizTitle);
        quiz.setDescription(quizDescription);
        quiz.setCreator(user);
        quiz.setCategory(category);
        quiz.setTags(tags);
        quiz.setStatus(QuizStatus.PUBLISHED);
        quiz.setVisibility(Visibility.PRIVATE);
        quiz.setEstimatedTime(estimatedTimeMinutes);
        quiz.setQuestions(new HashSet<>(allQuestions));
        quiz.setIsTimerEnabled(false);
        quiz.setIsRepetitionEnabled(false);
        quiz.setDifficulty(request.difficulty());

        return quizRepository.save(quiz);
    }

    @Override
    public String generateChunkTitle(int chunkIndex, List<Question> questions) {
        String uniqueId = UUID.randomUUID().toString().substring(0, 8);
        if (questions != null && !questions.isEmpty()) {
            String firstQuestion = questions.get(0).getQuestionText();
            if (firstQuestion != null && firstQuestion.length() > 10) {
                String[] words = firstQuestion.split("\\s+");
                if (words.length >= 3) {
                    String baseTitle = String.join(" ", Arrays.copyOfRange(words, 0, Math.min(5, words.length)));
                    return baseTitle + " (" + uniqueId + ")";
                }
            }
        }
        return String.format("Section %d (%s)", chunkIndex, uniqueId);
    }

    @Override
    public String ensureUniqueTitle(User user, String requestedTitle) {
        Objects.requireNonNull(user, "Creator must be provided for unique title generation");
        String baseTitle = Optional.ofNullable(requestedTitle)
                .map(String::trim)
                .filter(s -> !s.isEmpty())
                .orElse("Untitled Quiz");

        String normalized = truncateToLength(baseTitle, QUIZ_TITLE_MAX_LENGTH);
        if (!titleExistsForUser(user, normalized)) {
            return normalized;
        }

        String baseForSuffix = deriveSuffixBase(normalized);
        if (baseForSuffix.isBlank()) {
            baseForSuffix = normalized;
        }

        int suffix = 2;
        while (true) {
            String numericSuffix = "-" + suffix;
            int maxBaseLength = QUIZ_TITLE_MAX_LENGTH - numericSuffix.length();
            if (maxBaseLength <= 0) {
                throw new IllegalStateException("Unable to generate unique quiz title");
            }

            String candidateBase = baseForSuffix.length() > maxBaseLength
                    ? truncateToLength(baseForSuffix, maxBaseLength)
                    : baseForSuffix;

            candidateBase = removeTrailingHyphen(candidateBase);
            if (candidateBase.isBlank()) {
                candidateBase = truncateToLength("Quiz", maxBaseLength);
                if (candidateBase.isBlank()) {
                    candidateBase = "Q";
                }
            }

            String candidate = candidateBase + numericSuffix;
            if (!titleExistsForUser(user, candidate)) {
                return candidate;
            }
            suffix++;
        }
    }

    private boolean titleExistsForUser(User user, String title) {
        return quizRepository.existsByCreatorIdAndTitle(user.getId(), title);
    }

    private String truncateToLength(String value, int maxLength) {
        if (value.length() <= maxLength) {
            return value;
        }
        return value.substring(0, maxLength).stripTrailing();
    }

    private String deriveSuffixBase(String title) {
        int hyphenIndex = title.lastIndexOf('-');
        if (hyphenIndex > 0) {
            String suffixCandidate = title.substring(hyphenIndex + 1);
            if (!suffixCandidate.isBlank() && suffixCandidate.chars().allMatch(Character::isDigit)) {
                return title.substring(0, hyphenIndex).stripTrailing();
            }
        }
        return title;
    }

    private String removeTrailingHyphen(String value) {
        int end = value.length();
        while (end > 0 && value.charAt(end - 1) == '-') {
            end--;
        }
        return value.substring(0, end).stripTrailing();
    }
}
