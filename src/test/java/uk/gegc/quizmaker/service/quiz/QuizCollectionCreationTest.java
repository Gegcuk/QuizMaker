package uk.gegc.quizmaker.service.quiz;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import uk.gegc.quizmaker.features.category.domain.model.Category;
import uk.gegc.quizmaker.features.category.domain.repository.CategoryRepository;
import uk.gegc.quizmaker.features.question.domain.model.Difficulty;
import uk.gegc.quizmaker.features.question.domain.model.Question;
import uk.gegc.quizmaker.features.question.domain.model.QuestionType;
import uk.gegc.quizmaker.features.quiz.api.dto.GenerateQuizFromDocumentRequest;
import uk.gegc.quizmaker.features.quiz.api.dto.QuizScope;
import uk.gegc.quizmaker.features.quiz.application.impl.QuizServiceImpl;
import uk.gegc.quizmaker.features.quiz.domain.model.GenerationStatus;
import uk.gegc.quizmaker.features.quiz.domain.model.Quiz;
import uk.gegc.quizmaker.features.quiz.domain.model.QuizGenerationJob;
import uk.gegc.quizmaker.features.quiz.domain.repository.QuizGenerationJobRepository;
import uk.gegc.quizmaker.features.quiz.domain.repository.QuizRepository;
import uk.gegc.quizmaker.features.tag.domain.repository.TagRepository;
import uk.gegc.quizmaker.features.user.domain.model.User;

import java.util.*;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class QuizCollectionCreationTest {

    @Mock
    private QuizGenerationJobRepository jobRepository;

    @Mock
    private QuizRepository quizRepository;

    @Mock
    private CategoryRepository categoryRepository;

    @Mock
    private TagRepository tagRepository;

    @InjectMocks
    private QuizServiceImpl quizService;

    private User testUser;
    private QuizGenerationJob testJob;
    private GenerateQuizFromDocumentRequest testRequest;
    private Category testCategory;
    private UUID testJobId;
    private UUID testDocumentId;

    @BeforeEach
    void setUp() {
        testUser = new User();
        testUser.setUsername("testuser");

        testJobId = UUID.randomUUID();
        testDocumentId = UUID.randomUUID();

        testJob = new QuizGenerationJob();
        testJob.setId(testJobId);
        testJob.setUser(testUser);
        testJob.setDocumentId(testDocumentId);
        testJob.setStatus(GenerationStatus.PROCESSING);

        testCategory = new Category();
        testCategory.setName("AI Generated");
        testCategory.setDescription("Quizzes automatically generated by AI");

        Map<QuestionType, Integer> questionsPerType = new HashMap<>();
        questionsPerType.put(QuestionType.MCQ_SINGLE, 2);
        questionsPerType.put(QuestionType.TRUE_FALSE, 1);

        testRequest = new GenerateQuizFromDocumentRequest(
                testDocumentId,
                QuizScope.ENTIRE_DOCUMENT,
                null, // chunkIndices
                null, // chapterTitle
                null, // chapterNumber
                "Test Quiz",
                "Test description",
                questionsPerType,
                Difficulty.MEDIUM,
                2, // estimatedTimePerQuestion
                null, // categoryId
                List.of() // tagIds
        );
    }

    @Test
    void shouldCreateQuizCollectionSuccessfully() {
        // Given
        Map<Integer, List<Question>> chunkQuestions = createTestChunkQuestions();
        
        when(jobRepository.findById(testJobId)).thenReturn(Optional.of(testJob));
        when(categoryRepository.findByName("AI Generated")).thenReturn(Optional.of(testCategory));
        when(quizRepository.save(any(Quiz.class))).thenAnswer(invocation -> {
            Quiz quiz = invocation.getArgument(0);
            quiz.setId(UUID.randomUUID());
            return quiz;
        });

        // When
        quizService.createQuizCollectionFromGeneratedQuestions(testJobId, chunkQuestions, testRequest);

        // Then
        verify(jobRepository).findById(testJobId);
        verify(categoryRepository).findByName("AI Generated");
        
        // Should create 2 chunk quizzes + 1 consolidated quiz = 3 total
        verify(quizRepository, times(3)).save(any(Quiz.class));
        
        // Should update job with completed status
        verify(jobRepository).save(testJob);
        assertEquals(GenerationStatus.COMPLETED, testJob.getStatus());
        assertNotNull(testJob.getGeneratedQuizId());
        assertEquals(6, testJob.getTotalQuestionsGenerated()); // 2 chunks * 3 questions each
    }

    @Test
    void shouldCreateAICategoryIfNotExists() {
        // Given
        Map<Integer, List<Question>> chunkQuestions = createTestChunkQuestions();
        
        when(jobRepository.findById(testJobId)).thenReturn(Optional.of(testJob));
        when(categoryRepository.findByName("AI Generated")).thenReturn(Optional.empty());
        when(categoryRepository.findByName("General")).thenReturn(Optional.empty());
        when(categoryRepository.save(any(Category.class))).thenReturn(testCategory);
        when(quizRepository.save(any(Quiz.class))).thenAnswer(invocation -> {
            Quiz quiz = invocation.getArgument(0);
            quiz.setId(UUID.randomUUID());
            return quiz;
        });

        // When
        quizService.createQuizCollectionFromGeneratedQuestions(testJobId, chunkQuestions, testRequest);

        // Then
        verify(categoryRepository).findByName("AI Generated");
        verify(categoryRepository).findByName("General");
        verify(categoryRepository).save(any(Category.class));
        verify(quizRepository, times(3)).save(any(Quiz.class));
    }

    @Test
    void shouldHandleEmptyChunkQuestions() {
        // Given
        Map<Integer, List<Question>> chunkQuestions = new HashMap<>();
        
        when(jobRepository.findById(testJobId)).thenReturn(Optional.of(testJob));
        when(categoryRepository.findByName("AI Generated")).thenReturn(Optional.of(testCategory));
        when(quizRepository.save(any(Quiz.class))).thenAnswer(invocation -> {
            Quiz quiz = invocation.getArgument(0);
            quiz.setId(UUID.randomUUID());
            return quiz;
        });

        // When
        quizService.createQuizCollectionFromGeneratedQuestions(testJobId, chunkQuestions, testRequest);

        // Then
        verify(quizRepository, times(1)).save(any(Quiz.class)); // Only consolidated quiz
        verify(jobRepository).save(testJob);
        assertEquals(GenerationStatus.COMPLETED, testJob.getStatus());
        assertEquals(0, testJob.getTotalQuestionsGenerated());
    }

    @Test
    void shouldHandleJobNotFound() {
        // Given
        Map<Integer, List<Question>> chunkQuestions = createTestChunkQuestions();
        
        when(jobRepository.findById(testJobId)).thenReturn(Optional.empty());

        // When & Then
        assertThrows(RuntimeException.class, () -> {
            quizService.createQuizCollectionFromGeneratedQuestions(testJobId, chunkQuestions, testRequest);
        });
    }

    @Test
    void shouldHandleQuizCreationFailure() {
        // Given
        Map<Integer, List<Question>> chunkQuestions = createTestChunkQuestions();
        
        when(jobRepository.findById(testJobId)).thenReturn(Optional.of(testJob));
        when(categoryRepository.findByName("AI Generated")).thenReturn(Optional.of(testCategory));
        when(quizRepository.save(any(Quiz.class))).thenThrow(new RuntimeException("Database error"));

        // When & Then
        assertThrows(RuntimeException.class, () -> {
            quizService.createQuizCollectionFromGeneratedQuestions(testJobId, chunkQuestions, testRequest);
        });

        // Should mark job as failed
        verify(jobRepository, times(1)).save(testJob); // Only once for failure
        assertEquals(GenerationStatus.FAILED, testJob.getStatus());
        assertNotNull(testJob.getErrorMessage());
    }

    private Map<Integer, List<Question>> createTestChunkQuestions() {
        Map<Integer, List<Question>> chunkQuestions = new HashMap<>();
        
        // Create questions for chunk 0
        List<Question> chunk0Questions = Arrays.asList(
                createTestQuestion("Question 1 from chunk 0", QuestionType.MCQ_SINGLE),
                createTestQuestion("Question 2 from chunk 0", QuestionType.MCQ_SINGLE),
                createTestQuestion("Question 3 from chunk 0", QuestionType.TRUE_FALSE)
        );
        chunkQuestions.put(0, chunk0Questions);
        
        // Create questions for chunk 1
        List<Question> chunk1Questions = Arrays.asList(
                createTestQuestion("Question 1 from chunk 1", QuestionType.MCQ_SINGLE),
                createTestQuestion("Question 2 from chunk 1", QuestionType.MCQ_SINGLE),
                createTestQuestion("Question 3 from chunk 1", QuestionType.TRUE_FALSE)
        );
        chunkQuestions.put(1, chunk1Questions);
        
        return chunkQuestions;
    }

    private Question createTestQuestion(String questionText, QuestionType type) {
        Question question = new Question();
        question.setId(UUID.randomUUID());
        question.setQuestionText(questionText);
        question.setType(type);
        question.setDifficulty(Difficulty.MEDIUM);
        question.setContent("{\"question\":\"" + questionText + "\"}");
        return question;
    }
} 