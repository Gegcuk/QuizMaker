package uk.gegc.quizmaker.features.documentProcess.application;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import uk.gegc.quizmaker.features.documentProcess.domain.model.DocumentNode;
import uk.gegc.quizmaker.features.documentProcess.domain.model.NormalizedDocument;
import uk.gegc.quizmaker.features.documentProcess.infra.repository.DocumentNodeRepository;
import uk.gegc.quizmaker.features.documentProcess.infra.repository.NormalizedDocumentRepository;
import uk.gegc.quizmaker.shared.exception.ResourceNotFoundException;

import java.math.BigDecimal;
import java.util.*;

import static org.assertj.core.api.Assertions.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class ComprehensiveStructureServiceTest {

    @Mock
    private OpenAiLlmClient llmClient;

    @Mock
    private AnchorOffsetCalculator anchorOffsetCalculator;

    @Mock
    private DocumentNodeRepository nodeRepository;

    @Mock
    private NormalizedDocumentRepository documentRepository;

    @Mock
    private NodeHierarchyBuilder hierarchyBuilder;

    @InjectMocks
    private StructureService service;

    private UUID documentId;
    private NormalizedDocument document;
    private List<DocumentNode> testNodes;

    @BeforeEach
    void setUp() {
        documentId = UUID.randomUUID();
        document = new NormalizedDocument();
        document.setId(documentId);
        document.setOriginalName("comprehensive-test.txt");
        document.setStatus(NormalizedDocument.DocumentStatus.NORMALIZED);
        document.setNormalizedText(createTestDocumentText());
        document.setCharCount(createTestDocumentText().length());

        testNodes = createTestStructure();
    }

    @Test
    @DisplayName("Should handle empty AI response gracefully")
    void shouldHandleEmptyAiResponseGracefully() {
        // Given
        when(documentRepository.findById(documentId)).thenReturn(Optional.of(document));
        when(llmClient.generateStructure(any(), any())).thenReturn(Collections.emptyList());

        // When & Then
        assertThatThrownBy(() -> service.buildStructure(documentId))
            .isInstanceOf(ResourceNotFoundException.class)
            .hasMessageContaining("Document not found or no nodes generated by AI");
    }

    @Test
    @DisplayName("Should handle null AI response")
    void shouldHandleNullAiResponse() {
        // Given
        when(documentRepository.findById(documentId)).thenReturn(Optional.of(document));
        when(llmClient.generateStructure(any(), any())).thenReturn(null);

        // When & Then
        assertThatThrownBy(() -> service.buildStructure(documentId))
            .isInstanceOf(ResourceNotFoundException.class)
            .hasMessageContaining("Document not found or no nodes generated by AI");
    }

    @Test
    @DisplayName("Should handle document not found")
    void shouldHandleDocumentNotFound() {
        // Given
        when(documentRepository.findById(documentId)).thenReturn(Optional.empty());

        // When & Then
        assertThatThrownBy(() -> service.buildStructure(documentId))
            .isInstanceOf(ResourceNotFoundException.class)
            .hasMessageContaining("Document not found");
    }

    @Test
    @DisplayName("Should handle document in wrong status")
    void shouldHandleDocumentInWrongStatus() {
        // Given
        document.setStatus(NormalizedDocument.DocumentStatus.STRUCTURED);
        when(documentRepository.findById(documentId)).thenReturn(Optional.of(document));

        // When & Then
        assertThatThrownBy(() -> service.buildStructure(documentId))
            .isInstanceOf(IllegalStateException.class)
            .hasMessageContaining("Document must be in NORMALIZED status");
    }

    @Test
    @DisplayName("Should handle nodes with invalid offsets")
    void shouldHandleNodesWithInvalidOffsets() {
        // Given
        when(documentRepository.findById(documentId)).thenReturn(Optional.of(document));
        when(llmClient.generateStructure(any(), any())).thenReturn(testNodes);
        
        // Mock anchorOffsetCalculator to return invalid offsets
        when(anchorOffsetCalculator.calculateOffsets(anyList(), anyString()))
            .thenAnswer(invocation -> {
                List<DocumentNode> nodes = invocation.getArgument(0);
                nodes.forEach(node -> {
                    node.setStartOffset(-1); // Invalid negative offset
                    node.setEndOffset(100);
                });
                return nodes;
            });

        // When & Then
        assertThatThrownBy(() -> service.buildStructure(documentId))
            .isInstanceOf(IllegalStateException.class)
            .hasMessageContaining("Unexpected error during structure building");
    }

    @Test
    @DisplayName("Should handle nodes with end offset exceeding document length")
    void shouldHandleNodesWithEndOffsetExceedingDocumentLength() {
        // Given
        when(documentRepository.findById(documentId)).thenReturn(Optional.of(document));
        when(llmClient.generateStructure(any(), any())).thenReturn(testNodes);
        
        // Mock anchorOffsetCalculator to return offsets exceeding document length
        when(anchorOffsetCalculator.calculateOffsets(anyList(), anyString()))
            .thenAnswer(invocation -> {
                List<DocumentNode> nodes = invocation.getArgument(0);
                nodes.forEach(node -> {
                    node.setStartOffset(0);
                    node.setEndOffset(document.getCharCount() + 100); // Exceeds document length
                });
                return nodes;
            });

        // When & Then
        assertThatThrownBy(() -> service.buildStructure(documentId))
            .isInstanceOf(IllegalStateException.class)
            .hasMessageContaining("Unexpected error during structure building");
    }

    @Test
    @DisplayName("Should handle nodes with start offset >= end offset")
    void shouldHandleNodesWithStartOffsetGreaterThanOrEqualToEndOffset() {
        // Given
        when(documentRepository.findById(documentId)).thenReturn(Optional.of(document));
        when(llmClient.generateStructure(any(), any())).thenReturn(testNodes);
        
        // Mock anchorOffsetCalculator to return invalid offset ranges
        when(anchorOffsetCalculator.calculateOffsets(anyList(), anyString()))
            .thenAnswer(invocation -> {
                List<DocumentNode> nodes = invocation.getArgument(0);
                nodes.forEach(node -> {
                    node.setStartOffset(100);
                    node.setEndOffset(50); // End < Start
                });
                return nodes;
            });

        // When & Then
        assertThatThrownBy(() -> service.buildStructure(documentId))
            .isInstanceOf(IllegalStateException.class)
            .hasMessageContaining("Unexpected error during structure building");
    }

    @Test
    @DisplayName("Should handle null charCount gracefully")
    void shouldHandleNullCharCountGracefully() {
        // Given
        document.setCharCount(null);
        when(documentRepository.findById(documentId)).thenReturn(Optional.of(document));
        when(llmClient.generateStructure(any(), any())).thenReturn(testNodes);
        when(anchorOffsetCalculator.calculateOffsets(anyList(), anyString()))
            .thenAnswer(invocation -> {
                List<DocumentNode> nodes = invocation.getArgument(0);
                nodes.forEach(node -> {
                    node.setStartOffset(0);
                    node.setEndOffset(100);
                });
                return nodes;
            });
        when(nodeRepository.saveAll(anyList())).thenReturn(testNodes);
        when(nodeRepository.findByDocument_IdAndDepthLessThanOrderByStartOffset(any(), anyShort()))
            .thenReturn(Collections.emptyList());
        when(nodeRepository.findByDocument_IdOrderByStartOffset(any())).thenReturn(testNodes);
        doNothing().when(hierarchyBuilder).validateParentChildContainment(anyList());
        doNothing().when(anchorOffsetCalculator).validateSiblingNonOverlap(anyList());

        // When
        service.buildStructure(documentId);

        // Then - Should not throw exception
        verify(nodeRepository, times(3)).saveAll(anyList());
    }

    @Test
    @DisplayName("Should handle LLM client failure")
    void shouldHandleLlmClientFailure() {
        // Given
        when(documentRepository.findById(documentId)).thenReturn(Optional.of(document));
        when(llmClient.generateStructure(any(), any())).thenThrow(new RuntimeException("LLM service unavailable"));

        // When & Then
        assertThatThrownBy(() -> service.buildStructure(documentId))
            .isInstanceOf(IllegalStateException.class)
            .hasMessageContaining("Unexpected error during structure building");
    }

    @Test
    @DisplayName("Should handle anchor calculation failure")
    void shouldHandleAnchorCalculationFailure() {
        // Given
        when(documentRepository.findById(documentId)).thenReturn(Optional.of(document));
        when(llmClient.generateStructure(any(), any())).thenReturn(testNodes);
        when(anchorOffsetCalculator.calculateOffsets(anyList(), anyString()))
            .thenThrow(new RuntimeException("Anchor calculation failed"));

        // When & Then
        assertThatThrownBy(() -> service.buildStructure(documentId))
            .isInstanceOf(IllegalStateException.class)
            .hasMessageContaining("Unexpected error during structure building");
    }

    @Test
    @DisplayName("Should handle database save failure")
    void shouldHandleDatabaseSaveFailure() {
        // Given
        when(documentRepository.findById(documentId)).thenReturn(Optional.of(document));
        when(llmClient.generateStructure(any(), any())).thenReturn(testNodes);
        when(anchorOffsetCalculator.calculateOffsets(anyList(), anyString()))
            .thenAnswer(invocation -> {
                List<DocumentNode> nodes = invocation.getArgument(0);
                nodes.forEach(node -> {
                    node.setStartOffset(0);
                    node.setEndOffset(100);
                });
                return nodes;
            });
        when(nodeRepository.saveAll(anyList())).thenThrow(new RuntimeException("Database connection failed"));

        // When & Then
        assertThatThrownBy(() -> service.buildStructure(documentId))
            .isInstanceOf(IllegalStateException.class)
            .hasMessageContaining("Unexpected error during structure building");
    }

    @Test
    @DisplayName("Should handle parent relationship assignment failure")
    void shouldHandleParentRelationshipAssignmentFailure() {
        // Given
        when(documentRepository.findById(documentId)).thenReturn(Optional.of(document));
        when(llmClient.generateStructure(any(), any())).thenReturn(testNodes);
        when(anchorOffsetCalculator.calculateOffsets(anyList(), anyString()))
            .thenAnswer(invocation -> {
                List<DocumentNode> nodes = invocation.getArgument(0);
                nodes.forEach(node -> {
                    node.setStartOffset(0);
                    node.setEndOffset(100);
                });
                return nodes;
            });
        when(nodeRepository.findByDocument_IdAndDepthLessThanOrderByStartOffset(any(), anyShort()))
            .thenThrow(new RuntimeException("Database query failed"));

        // When & Then
        assertThatThrownBy(() -> service.buildStructure(documentId))
            .isInstanceOf(IllegalStateException.class)
            .hasMessageContaining("Unexpected error during structure building");
    }

    @Test
    @DisplayName("Should handle global validation failure gracefully")
    void shouldHandleGlobalValidationFailure() {
        // Given
        when(documentRepository.findById(documentId)).thenReturn(Optional.of(document));
        when(llmClient.generateStructure(any(), any())).thenReturn(testNodes);
        when(anchorOffsetCalculator.calculateOffsets(anyList(), anyString()))
            .thenAnswer(invocation -> {
                List<DocumentNode> nodes = invocation.getArgument(0);
                nodes.forEach(node -> {
                    node.setStartOffset(0);
                    node.setEndOffset(100);
                });
                return nodes;
            });
        when(nodeRepository.saveAll(anyList())).thenReturn(testNodes);
        when(nodeRepository.findByDocument_IdAndDepthLessThanOrderByStartOffset(any(), anyShort()))
            .thenReturn(Collections.emptyList());
        when(nodeRepository.findByDocument_IdOrderByStartOffset(any())).thenReturn(testNodes);
        doThrow(new RuntimeException("Global validation failed")).when(hierarchyBuilder).validateParentChildContainment(anyList());

        // When - Should not throw exception due to resilient validation
        service.buildStructure(documentId);

        // Then - Verify that nodes were still saved despite validation failure
        verify(nodeRepository, times(3)).saveAll(anyList()); // 3 depth levels
        verify(hierarchyBuilder).validateParentChildContainment(anyList());
    }

    @Test
    @DisplayName("Should handle sibling overlap validation failure gracefully")
    void shouldHandleSiblingOverlapValidationFailure() {
        // Given
        when(documentRepository.findById(documentId)).thenReturn(Optional.of(document));
        when(llmClient.generateStructure(any(), any())).thenReturn(testNodes);
        when(anchorOffsetCalculator.calculateOffsets(anyList(), anyString()))
            .thenAnswer(invocation -> {
                List<DocumentNode> nodes = invocation.getArgument(0);
                nodes.forEach(node -> {
                    node.setStartOffset(0);
                    node.setEndOffset(100);
                });
                return nodes;
            });
        when(nodeRepository.saveAll(anyList())).thenReturn(testNodes);
        when(nodeRepository.findByDocument_IdAndDepthLessThanOrderByStartOffset(any(), anyShort()))
            .thenReturn(Collections.emptyList());
        when(nodeRepository.findByDocument_IdOrderByStartOffset(any())).thenReturn(testNodes);
        doNothing().when(hierarchyBuilder).validateParentChildContainment(anyList());
        doThrow(new RuntimeException("Sibling overlap detected")).when(anchorOffsetCalculator).validateSiblingNonOverlap(anyList());

        // When - Should not throw exception due to resilient validation
        service.buildStructure(documentId);

        // Then - Verify that nodes were still saved despite validation failure
        verify(nodeRepository, times(3)).saveAll(anyList()); // 3 depth levels
        verify(anchorOffsetCalculator).validateSiblingNonOverlap(anyList());
    }

    @Test
    @DisplayName("Should handle single level structure successfully")
    void shouldHandleSingleLevelStructureSuccessfully() {
        // Given
        List<DocumentNode> singleLevelNodes = createSingleLevelStructure();
        when(documentRepository.findById(documentId)).thenReturn(Optional.of(document));
        when(llmClient.generateStructure(any(), any())).thenReturn(singleLevelNodes);
        when(anchorOffsetCalculator.calculateOffsets(anyList(), anyString()))
            .thenAnswer(invocation -> {
                List<DocumentNode> nodes = invocation.getArgument(0);
                nodes.forEach(node -> {
                    node.setStartOffset(0);
                    node.setEndOffset(100);
                });
                return nodes;
            });
        when(nodeRepository.saveAll(anyList())).thenReturn(singleLevelNodes);
        when(nodeRepository.findByDocument_IdOrderByStartOffset(any())).thenReturn(singleLevelNodes);
        doNothing().when(hierarchyBuilder).validateParentChildContainment(anyList());
        doNothing().when(anchorOffsetCalculator).validateSiblingNonOverlap(anyList());

        // When
        service.buildStructure(documentId);

        // Then
        verify(nodeRepository, times(1)).saveAll(anyList());
        verify(hierarchyBuilder).validateParentChildContainment(anyList());
        verify(anchorOffsetCalculator).validateSiblingNonOverlap(anyList());
    }

    @Test
    @DisplayName("Should handle deep nested structure successfully")
    void shouldHandleDeepNestedStructureSuccessfully() {
        // Given
        List<DocumentNode> deepNestedNodes = createDeepNestedStructure();
        when(documentRepository.findById(documentId)).thenReturn(Optional.of(document));
        when(llmClient.generateStructure(any(), any())).thenReturn(deepNestedNodes);
        when(anchorOffsetCalculator.calculateOffsets(anyList(), anyString()))
            .thenAnswer(invocation -> {
                List<DocumentNode> nodes = invocation.getArgument(0);
                nodes.forEach(node -> {
                    node.setStartOffset(0);
                    node.setEndOffset(100);
                });
                return nodes;
            });
        when(nodeRepository.saveAll(anyList())).thenReturn(deepNestedNodes);
        when(nodeRepository.findByDocument_IdAndDepthLessThanOrderByStartOffset(any(), anyShort()))
            .thenReturn(Collections.emptyList());
        when(nodeRepository.findByDocument_IdOrderByStartOffset(any())).thenReturn(deepNestedNodes);
        doNothing().when(hierarchyBuilder).validateParentChildContainment(anyList());
        doNothing().when(anchorOffsetCalculator).validateSiblingNonOverlap(anyList());

        // When
        service.buildStructure(documentId);

        // Then - Should save each level separately
        verify(nodeRepository, times(4)).saveAll(anyList()); // 4 depth levels
        verify(nodeRepository, times(3)).findByDocument_IdAndDepthLessThanOrderByStartOffset(any(), anyShort());
    }

    @Test
    @DisplayName("Should handle nodes with missing required fields")
    void shouldHandleNodesWithMissingRequiredFields() {
        // Given
        List<DocumentNode> invalidNodes = createInvalidNodes();
        when(documentRepository.findById(documentId)).thenReturn(Optional.of(document));
        when(llmClient.generateStructure(any(), any())).thenReturn(invalidNodes);

        // When & Then
        assertThatThrownBy(() -> service.buildStructure(documentId))
            .isInstanceOf(IllegalStateException.class)
            .hasMessageContaining("Unexpected error during structure building");
    }

    @Test
    @DisplayName("Should handle concurrent modification during processing")
    void shouldHandleConcurrentModificationDuringProcessing() {
        // Given
        when(documentRepository.findById(documentId)).thenReturn(Optional.of(document));
        when(llmClient.generateStructure(any(), any())).thenReturn(testNodes);
        when(anchorOffsetCalculator.calculateOffsets(anyList(), anyString()))
            .thenAnswer(invocation -> {
                List<DocumentNode> nodes = invocation.getArgument(0);
                nodes.forEach(node -> {
                    node.setStartOffset(0);
                    node.setEndOffset(100);
                });
                return nodes;
            });
        when(nodeRepository.saveAll(anyList())).thenReturn(testNodes);
        when(nodeRepository.findByDocument_IdAndDepthLessThanOrderByStartOffset(any(), anyShort()))
            .thenReturn(Collections.emptyList());
        when(nodeRepository.findByDocument_IdOrderByStartOffset(any())).thenReturn(testNodes);
        doNothing().when(hierarchyBuilder).validateParentChildContainment(anyList());
        doNothing().when(anchorOffsetCalculator).validateSiblingNonOverlap(anyList());

        // When
        service.buildStructure(documentId);

        // Then - Should handle concurrent modification gracefully
        verify(nodeRepository, times(3)).saveAll(anyList());
    }

    @Test
    @DisplayName("Should handle very large document text")
    void shouldHandleVeryLargeDocumentText() {
        // Given
        String largeText = "A".repeat(100000); // 100KB text
        document.setNormalizedText(largeText);
        document.setCharCount(largeText.length());
        
        when(documentRepository.findById(documentId)).thenReturn(Optional.of(document));
        when(llmClient.generateStructure(any(), any())).thenReturn(testNodes);
        when(anchorOffsetCalculator.calculateOffsets(anyList(), anyString()))
            .thenAnswer(invocation -> {
                List<DocumentNode> nodes = invocation.getArgument(0);
                nodes.forEach(node -> {
                    node.setStartOffset(0);
                    node.setEndOffset(100);
                });
                return nodes;
            });
        when(nodeRepository.saveAll(anyList())).thenReturn(testNodes);
        when(nodeRepository.findByDocument_IdAndDepthLessThanOrderByStartOffset(any(), anyShort()))
            .thenReturn(Collections.emptyList());
        when(nodeRepository.findByDocument_IdOrderByStartOffset(any())).thenReturn(testNodes);
        doNothing().when(hierarchyBuilder).validateParentChildContainment(anyList());
        doNothing().when(anchorOffsetCalculator).validateSiblingNonOverlap(anyList());

        // When
        service.buildStructure(documentId);

        // Then - Should handle large text without issues
        verify(nodeRepository, times(3)).saveAll(anyList());
    }

    @Test
    @DisplayName("Should handle nodes with special characters in titles")
    void shouldHandleNodesWithSpecialCharactersInTitles() {
        // Given
        List<DocumentNode> specialCharNodes = createNodesWithSpecialCharacters();
        when(documentRepository.findById(documentId)).thenReturn(Optional.of(document));
        when(llmClient.generateStructure(any(), any())).thenReturn(specialCharNodes);
        when(anchorOffsetCalculator.calculateOffsets(anyList(), anyString()))
            .thenAnswer(invocation -> {
                List<DocumentNode> nodes = invocation.getArgument(0);
                nodes.forEach(node -> {
                    node.setStartOffset(0);
                    node.setEndOffset(100);
                });
                return nodes;
            });
        when(nodeRepository.saveAll(anyList())).thenReturn(specialCharNodes);

        // When
        service.buildStructure(documentId);

        // Then - Should handle special characters without issues
        verify(nodeRepository, times(1)).saveAll(anyList());
    }

    private String createTestDocumentText() {
        return "This is a comprehensive test document for thorough testing. " +
               "It contains multiple sections and subsections with various content. " +
               "The document is structured in a hierarchical manner for testing purposes. " +
               "Each level has specific content and structure to validate the system.";
    }

    private List<DocumentNode> createTestStructure() {
        List<DocumentNode> nodes = new ArrayList<>();

        // Depth 0
        DocumentNode root = new DocumentNode();
        root.setType(DocumentNode.NodeType.CHAPTER);
        root.setTitle("Root Chapter");
        root.setStartAnchor("Root Chapter");
        root.setEndAnchor("End Root Chapter");
        root.setDepth((short) 0);
        root.setAiConfidence(BigDecimal.valueOf(0.95));
        nodes.add(root);

        // Depth 1
        DocumentNode section1 = new DocumentNode();
        section1.setType(DocumentNode.NodeType.SECTION);
        section1.setTitle("Section 1");
        section1.setStartAnchor("Section 1");
        section1.setEndAnchor("End Section 1");
        section1.setDepth((short) 1);
        section1.setAiConfidence(BigDecimal.valueOf(0.9));
        nodes.add(section1);

        DocumentNode section2 = new DocumentNode();
        section2.setType(DocumentNode.NodeType.SECTION);
        section2.setTitle("Section 2");
        section2.setStartAnchor("Section 2");
        section2.setEndAnchor("End Section 2");
        section2.setDepth((short) 1);
        section2.setAiConfidence(BigDecimal.valueOf(0.9));
        nodes.add(section2);

        // Depth 2
        DocumentNode subsection1 = new DocumentNode();
        subsection1.setType(DocumentNode.NodeType.SUBSECTION);
        subsection1.setTitle("Subsection 1.1");
        subsection1.setStartAnchor("Subsection 1.1");
        subsection1.setEndAnchor("End Subsection 1.1");
        subsection1.setDepth((short) 2);
        subsection1.setAiConfidence(BigDecimal.valueOf(0.85));
        nodes.add(subsection1);

        return nodes;
    }

    private List<DocumentNode> createSingleLevelStructure() {
        List<DocumentNode> nodes = new ArrayList<>();
        
        DocumentNode node = new DocumentNode();
        node.setType(DocumentNode.NodeType.CHAPTER);
        node.setTitle("Single Level");
        node.setStartAnchor("Single Level");
        node.setEndAnchor("End Single Level");
        node.setDepth((short) 0);
        node.setAiConfidence(BigDecimal.valueOf(0.95));
        nodes.add(node);
        
        return nodes;
    }

    private List<DocumentNode> createDeepNestedStructure() {
        List<DocumentNode> nodes = new ArrayList<>();

        // Depth 0
        DocumentNode root = new DocumentNode();
        root.setType(DocumentNode.NodeType.CHAPTER);
        root.setTitle("Deep Root");
        root.setStartAnchor("Deep Root");
        root.setEndAnchor("End Deep Root");
        root.setDepth((short) 0);
        root.setAiConfidence(BigDecimal.valueOf(0.95));
        nodes.add(root);

        // Depth 1
        DocumentNode level1 = new DocumentNode();
        level1.setType(DocumentNode.NodeType.SECTION);
        level1.setTitle("Level 1");
        level1.setStartAnchor("Level 1");
        level1.setEndAnchor("End Level 1");
        level1.setDepth((short) 1);
        level1.setAiConfidence(BigDecimal.valueOf(0.9));
        nodes.add(level1);

        // Depth 2
        DocumentNode level2 = new DocumentNode();
        level2.setType(DocumentNode.NodeType.SUBSECTION);
        level2.setTitle("Level 2");
        level2.setStartAnchor("Level 2");
        level2.setEndAnchor("End Level 2");
        level2.setDepth((short) 2);
        level2.setAiConfidence(BigDecimal.valueOf(0.85));
        nodes.add(level2);

        // Depth 3
        DocumentNode level3 = new DocumentNode();
        level3.setType(DocumentNode.NodeType.SUBSECTION);
        level3.setTitle("Level 3");
        level3.setStartAnchor("Level 3");
        level3.setEndAnchor("End Level 3");
        level3.setDepth((short) 3);
        level3.setAiConfidence(BigDecimal.valueOf(0.8));
        nodes.add(level3);

        return nodes;
    }

    private List<DocumentNode> createInvalidNodes() {
        List<DocumentNode> nodes = new ArrayList<>();
        
        // Node with null title
        DocumentNode invalidNode1 = new DocumentNode();
        invalidNode1.setType(DocumentNode.NodeType.CHAPTER);
        invalidNode1.setTitle(null);
        invalidNode1.setDepth((short) 0);
        nodes.add(invalidNode1);
        
        // Node with null type
        DocumentNode invalidNode2 = new DocumentNode();
        invalidNode2.setTitle("Valid Title");
        invalidNode2.setType(null);
        invalidNode2.setDepth((short) 0);
        nodes.add(invalidNode2);
        
        return nodes;
    }

    private List<DocumentNode> createNodesWithSpecialCharacters() {
        List<DocumentNode> nodes = new ArrayList<>();
        
        DocumentNode specialNode = new DocumentNode();
        specialNode.setType(DocumentNode.NodeType.CHAPTER);
        specialNode.setTitle("Special Characters: !@#$%^&*()_+-=[]{}|;':\",./<>?");
        specialNode.setStartAnchor("Special Characters");
        specialNode.setEndAnchor("End Special Characters");
        specialNode.setDepth((short) 0);
        specialNode.setAiConfidence(BigDecimal.valueOf(0.95));
        nodes.add(specialNode);
        
        return nodes;
    }
}
