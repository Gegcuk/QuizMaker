name: Deploy Backend to Production

on:
  push:
    branches: [ master, main ]
    paths:
      - 'src/**'
      - 'pom.xml'
      - 'server/backend/**'
      - '.github/workflows/deploy-backend.yml'

jobs:
  deploy-backend:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'
          cache: maven

      - name: Build application
        run: |
          ./mvnw clean package -DskipTests -B
          echo "‚úÖ Application built successfully"

      - name: Prepare deployment bundle
        run: |
          rm -rf deployment && mkdir -p deployment
          
          # Copy backend deployment files
          cp -r server/backend/* deployment/
          
          # Copy application files (target/ not needed as Dockerfile rebuilds from source)
          cp pom.xml deployment/
          cp -r src deployment/
          
          # Create production properties
          cp server/backend/application-prod.properties deployment/src/main/resources/
          
          echo "üîç Debug: Checking deployment bundle contents:"
          ls -la deployment/ || echo "Deployment directory not found"
          echo "üîç Debug: Checking if mysql-init directory was copied:"
          ls -la deployment/mysql-init/ || echo "mysql-init directory not found in deployment"
          
          echo "‚úÖ Deployment bundle prepared"

      - name: Stop old backend (ignore if first run)
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          script: |
            set -e
            mkdir -p /var/www/quizmaker-backend
            cd /var/www/quizmaker-backend
            
            # Load environment variables if .env exists
            if [ -f .env ]; then
              echo "üîç Attempting to load existing environment variables (non-fatal if parsing fails)..."
              set -a
              if ! source .env 2>/dev/null; then
                echo "‚ö†Ô∏è Warning: Failed to parse existing .env file. Continuing without exporting variables."
              fi
              set +a
            fi
            
            # Stop existing containers
            docker compose down || true
            
            # Clean up old images to save space
            docker image prune -f || true
            
            echo "‚úÖ Old backend stopped"

      - name: Copy deployment files
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          source: "deployment/*"
          target: "/var/www/quizmaker-backend/"
          strip_components: 1
          overwrite: true

      - name: Create environment file and deploy
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          script: |
            set -e
            cd /var/www/quizmaker-backend
            
            # Create .env file from secrets
            cat > .env <<'EOF'
            # Database Configuration
            DB_USERNAME="${{ secrets.DB_PROD_USERNAME || 'quizmaker_user' }}"
            DB_PASSWORD="${{ secrets.DB_PASSWORD }}"
            DB_ROOT_PASSWORD="${{ secrets.DB_ROOT_PASSWORD }}"
            MYSQL_ROOT_PASSWORD="${{ secrets.DB_ROOT_PASSWORD }}"
            
            # JWT Configuration
            JWT_SECRET="${{ secrets.JWT_SECRET }}"
            
            # Security Peppers
            TOKEN_PEPPER_SECRET="${{ secrets.TOKEN_PEPPER_SECRET }}"
            RESET_TOKEN_PEPPER="${{ secrets.RESET_TOKEN_PEPPER }}"
            VERIFICATION_TOKEN_PEPPER="${{ secrets.VERIFICATION_TOKEN_PEPPER }}"
            
            # OpenAI Configuration
            OPENAI_API_KEY="${{ secrets.OPENAI_API_KEY }}"
            OPENAI_MODEL="${{ secrets.OPENAI_MODEL }}"
            
            # Stripe Configuration
            STRIPE_SECRET_KEY="${{ secrets.STRIPE_SECRET_KEY }}"
            STRIPE_WEBHOOK_SECRET="${{ secrets.STRIPE_WEBHOOK_SECRET }}"
            STRIPE_PUBLISHABLE_KEY="${{ secrets.STRIPE_PUBLISHABLE_KEY }}"
            STRIPE_PRICE_SMALL="${{ secrets.STRIPE_PRICE_SMALL }}"
            STRIPE_PRICE_MEDIUM="${{ secrets.STRIPE_PRICE_MEDIUM }}"
            STRIPE_PRICE_LARGE="${{ secrets.STRIPE_PRICE_LARGE }}"
            STRIPE_PRICE_SUBSCRIPTION="${{ secrets.STRIPE_PRICE_SUBSCRIPTION }}"
            
            # Email Configuration
            SMTP_HOST="${{ secrets.SMTP_HOST }}"
            SMTP_PORT="${{ secrets.SMTP_PORT }}"
            SMTP_USERNAME="${{ secrets.SMTP_USERNAME }}"
            SMTP_PASSWORD="${{ secrets.SMTP_PASSWORD }}"
            
            # Frontend Configuration
            FRONTEND_BASE_URL="${{ secrets.FRONTEND_BASE_URL }}"
            
            # Billing Configuration (optional)
            BILLING_TOKEN_TO_LLM_RATIO="${{ secrets.BILLING_TOKEN_TO_LLM_RATIO || '1.0' }}"
            BILLING_RESERVATION_TTL_MINUTES="${{ secrets.BILLING_RESERVATION_TTL_MINUTES || '30' }}"
            BILLING_SAFETY_FACTOR="${{ secrets.BILLING_SAFETY_FACTOR || '1.2' }}"
            BILLING_CURRENCY="${{ secrets.BILLING_CURRENCY || 'USD' }}"
            EOF
            
            # Verify .env file was created successfully
            if [ ! -f .env ]; then
              echo "‚ùå Failed to create .env file!"
              exit 1
            fi
            
            # Set proper permissions
            chmod 600 .env
            
            # Verify .env file is readable and has content
            if [ ! -s .env ]; then
              echo "‚ùå .env file is empty!"
              exit 1
            fi
            
            # Make MySQL init scripts executable
            chmod +x mysql-init/*.sh 2>/dev/null || true
            
            echo "üîç Debug: MySQL init scripts status:"
            ls -la mysql-init/ || echo "mysql-init directory not found"
            echo "üîç Debug: Checking if init scripts are executable:"
            find mysql-init/ -name "*.sh" -exec ls -la {} \; || echo "No .sh files found"
            echo "üîç Debug: Checking all files in mysql-init directory:"
            find mysql-init/ -type f -exec ls -la {} \; 2>/dev/null || echo "mysql-init directory not accessible"
            
            echo "‚úÖ Environment file created"
            echo "üìã Environment file structure (without sensitive values):"
            grep -E "^[A-Z_]+=.*" .env | sed 's/=.*/=[HIDDEN]/' || true
            
            echo "üîç Debug: Checking specific variables:"
            db_username_length=$(printf '%s' "${DB_USERNAME:-}" | wc -c)
            db_password_length=$(printf '%s' "${DB_PASSWORD:-}" | wc -c)
            db_root_password_length=$(printf '%s' "${DB_ROOT_PASSWORD:-}" | wc -c)
            echo "DB_USERNAME length: ${db_username_length}"
            echo "DB_PASSWORD length: ${db_password_length}"
            echo "DB_ROOT_PASSWORD length: ${db_root_password_length}"
            echo "DB_USERNAME value: '$DB_USERNAME'"
            echo "DB_PASSWORD first 3 chars: '$(echo "$DB_PASSWORD" | cut -c1-3)...'"
            echo "DB_ROOT_PASSWORD first 3 chars: '$(echo "$DB_ROOT_PASSWORD" | cut -c1-3)...'"
            
            echo "üîç Debug: Environment file contents (sanitized):"
            cat .env | sed 's/=.*/=[REDACTED]/' | head -10
            
            echo "üîç Debug: Checking if .env file exists and is readable:"
            ls -la .env || echo "‚ùå .env file not found!"
            
            echo "üîç Debug: First 5 lines of .env file:"
            head -5 .env || echo "‚ùå Cannot read .env file!"
            
            echo "üîç Debug: Loading .env file and checking variables:"
            set -a
            if ! source .env 2>/dev/null; then
              echo "‚ö†Ô∏è Warning: Failed to load .env file for debugging output."
            fi
            set +a
            echo "After loading .env:"
            echo "DB_USERNAME: '${DB_USERNAME:-NOT_SET}'"
            db_password_length=$(printf '%s' "${DB_PASSWORD:-}" | wc -c)
            db_root_password_length=$(printf '%s' "${DB_ROOT_PASSWORD:-}" | wc -c)
            echo "DB_PASSWORD length: ${db_password_length}"
            echo "DB_ROOT_PASSWORD length: ${db_root_password_length}"

      - name: Build and start backend
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          script: |
            set -e
            cd /var/www/quizmaker-backend
            
            # Check if .env file exists first
            echo "üîç Checking if .env file exists..."
            if [ ! -f .env ]; then
              echo "‚ùå .env file does not exist! Cannot proceed."
              echo "üìã Current directory contents:"
              ls -la
              exit 1
            fi
            
            echo "‚úÖ .env file exists. Checking its contents..."
            echo "üìã .env file size: $(wc -c < .env) bytes"
            echo "üìã .env file line count: $(wc -l < .env) lines"
            echo "üìã First 10 lines of .env file:"
            head -10 .env || echo "Cannot read .env file"
            
            # Load environment variables from .env file
            echo "üîç Loading environment variables from .env file..."
            sed -i 's/\r$//' .env

            # Try to load with verbose error output first
            echo "üîç Attempting to source .env file with verbose output:"
            if ! source .env; then
              echo "‚ùå Failed to source .env file. Checking for specific issues..."
              
              # Check for problematic characters
              echo "üìã Checking for non-printable characters:"
              hexdump -C .env | head -10
              
              # Check for specific problematic patterns
              echo "üìã Checking for problematic patterns:"
              grep -n '[[:space:]]$' .env || echo "No trailing whitespace found"
              grep -n '^[[:space:]]' .env || echo "No leading whitespace found"
              grep -n '=' .env | head -5 || echo "No equals signs found"
              
              # Try loading line by line to find the problematic line
              echo "üìã Testing .env file line by line:"
              line_num=0
              while IFS= read -r line; do
                line_num=$((line_num + 1))
                if [[ "$line" =~ ^[[:space:]]*# ]] || [[ -z "$line" ]]; then
                  echo "Line $line_num: OK (comment/empty): $line"
                elif [[ "$line" =~ ^[A-Z_]+= ]]; then
                  echo "Line $line_num: OK (variable): ${line%%=*}=[HIDDEN]"
                else
                  echo "Line $line_num: PROBLEMATIC: '$line'"
                  break
                fi
              done < .env
              
              exit 1
            fi

            echo "‚úÖ Successfully loaded .env file"
            
            if [ -z "${MYSQL_ROOT_PASSWORD:-}" ] && [ -n "${DB_ROOT_PASSWORD:-}" ]; then
              export MYSQL_ROOT_PASSWORD="${DB_ROOT_PASSWORD}"
              echo "‚ÑπÔ∏è  MYSQL_ROOT_PASSWORD not provided. Falling back to DB_ROOT_PASSWORD."
            fi

            if [ -z "${MYSQL_ROOT_PASSWORD:-}" ]; then
              echo "‚ùå MYSQL_ROOT_PASSWORD is required but not set."
              exit 1
            fi

            echo "üîç Environment variables loaded:"
            echo "DB_USERNAME: '${DB_USERNAME:-NOT_SET}'"
            db_password_length=$(printf '%s' "${DB_PASSWORD:-}" | wc -c)
            db_root_password_length=$(printf '%s' "${DB_ROOT_PASSWORD:-}" | wc -c)
            mysql_root_password_length=$(printf '%s' "${MYSQL_ROOT_PASSWORD:-}" | wc -c)
            echo "DB_PASSWORD length: ${db_password_length}"
            echo "DB_ROOT_PASSWORD length: ${db_root_password_length}"
            echo "MYSQL_ROOT_PASSWORD length: ${mysql_root_password_length}"
            
            # Verify docker-compose.yml syntax
            echo "üîç Verifying Docker Compose configuration..."
            docker compose config --quiet
            
            # Build and start services
            echo "üî® Building backend container..."
            docker compose build --no-cache
            
            echo "üßπ Clearing MySQL data volume (version compatibility issue)..."
            docker compose down -v || true
            docker volume rm quizmaker-backend_mysql_data || true
            
            # Also clear any existing Flyway schema history if it exists
            echo "üßπ Ensuring clean database state for Flyway..."
            docker volume rm quizmaker-backend_mysql_data 2>/dev/null || true
            
            # Force remove any lingering volumes
            docker volume prune -f || true
            
            echo "üöÄ Starting MySQL first..."
            docker compose up -d mysql
            
            echo "‚è≥ Waiting for MySQL to be ready before starting backend..."
            # Wait for MySQL to be healthy before starting backend
            for i in {1..60}; do
              if docker compose exec -e MYSQL_PWD="$MYSQL_ROOT_PASSWORD" mysql mysqladmin ping -h localhost -u root --silent 2>/dev/null; then
                echo "‚úÖ MySQL is ready! Starting backend..."
                
                # Check if init scripts were copied and are executable
                echo "üîç Checking MySQL init scripts in container..."
                docker compose exec mysql ls -la /docker-entrypoint-initdb.d/ || echo "Cannot access init directory"
                
                # Check MySQL initialization logs
                echo "üîç Checking MySQL initialization logs..."
                docker compose logs mysql | grep -Ei "\[mysql-init\]|DEBUG:|ERROR:|initdb|Entrypoint" || echo "No init logs found"
                
                # Check MySQL container environment variables
                echo "üîç Checking MySQL container environment variables..."
                docker compose exec mysql env | grep MYSQL || echo "No MYSQL environment variables found"
                
                # Check if initialization scripts ran, and run them manually if needed
                echo "üîç Checking if MySQL initialization is needed..."
                
                # Try to connect with root password
                if ! docker compose exec -e MYSQL_PWD="$MYSQL_ROOT_PASSWORD" mysql mysql -uroot -e "SELECT 1;" >/dev/null 2>&1; then
                  echo "‚ö†Ô∏è Cannot connect with root password, running initialization script manually..."
                  
                  # Try running the init script
                  if docker compose exec mysql /docker-entrypoint-initdb.d/01-init.sh; then
                    echo "‚úÖ Initialization script completed successfully"
                  else
                    echo "‚ö†Ô∏è Initialization script failed, trying manual setup..."
                    
                    # Try to connect without password and set the password manually
                    if docker compose exec mysql mysql -uroot -e "SELECT 1;" >/dev/null 2>&1; then
                      echo "üîß Setting root password manually..."
                      docker compose exec mysql mysql -uroot -e "ALTER USER 'root'@'localhost' IDENTIFIED BY '$MYSQL_ROOT_PASSWORD';"
                      docker compose exec mysql mysql -uroot -e "ALTER USER 'root'@'%' IDENTIFIED BY '$MYSQL_ROOT_PASSWORD';"
                      docker compose exec mysql mysql -uroot -e "FLUSH PRIVILEGES;"
                      echo "‚úÖ Root password set manually"
                    else
                      echo "‚ùå Cannot connect to MySQL with or without password"
                      echo "üìã MySQL container logs:"
                      docker compose logs --tail=20 mysql
                      exit 1
                    fi
                  fi
                  
                  # Wait a moment for initialization to complete
                  sleep 3
                else
                  echo "‚úÖ Root password connection successful"
                fi
                
                # Check MySQL users after initialization
                echo "üîç Checking MySQL users after initialization..."
                docker compose exec -e MYSQL_PWD="$MYSQL_ROOT_PASSWORD" mysql mysql -uroot -e "SELECT User, Host FROM mysql.user WHERE User NOT IN ('mysql.session', 'mysql.sys', 'mysql.infoschema', '');" 2>/dev/null || echo "Could not check users"
                
                # Verify application user exists with % host
                app_user_check=$(docker compose exec -e MYSQL_PWD="$MYSQL_ROOT_PASSWORD" mysql mysql -uroot -e "SELECT COUNT(*) FROM mysql.user WHERE User='$DB_USERNAME' AND Host='%';" 2>/dev/null | tail -1 | tr -d '\r' || echo "0")
                
                if [ "$app_user_check" = "0" ]; then
                  echo "‚ö†Ô∏è Application user '$DB_USERNAME' not found with % host access!"
                  echo "üîß Creating application user manually..."
                  docker compose exec -e MYSQL_PWD="$MYSQL_ROOT_PASSWORD" mysql mysql -uroot -e "
                    CREATE DATABASE IF NOT EXISTS \`quizmakerdb\` CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
                    CREATE USER IF NOT EXISTS '$DB_USERNAME'@'%' IDENTIFIED BY '$DB_PASSWORD';
                    GRANT ALL PRIVILEGES ON \`quizmakerdb\`.* TO '$DB_USERNAME'@'%';
                    FLUSH PRIVILEGES;
                  " || echo "Manual user creation failed"
                  
                  # Verify again
                  app_user_check=$(docker compose exec -e MYSQL_PWD="$MYSQL_ROOT_PASSWORD" mysql mysql -uroot -e "SELECT COUNT(*) FROM mysql.user WHERE User='$DB_USERNAME' AND Host='%';" 2>/dev/null | tail -1 | tr -d '\r' || echo "0")
                  if [ "$app_user_check" = "0" ]; then
                    echo "‚ùå Failed to create application user. Aborting deployment."
                    exit 1
                  else
                    echo "‚úÖ Application user created successfully!"
                  fi
                else
                  echo "‚úÖ Application user '$DB_USERNAME' found with % host access!"
                fi
                
                # Check if Flyway schema history exists and clean it if corrupted
                echo "üîç Checking Flyway schema history..."
                docker compose exec -e MYSQL_PWD="$MYSQL_ROOT_PASSWORD" mysql mysql -uroot -e "USE quizmakerdb; SHOW TABLES LIKE 'flyway_schema_history';" 2>/dev/null || echo "Cannot check Flyway history"
                
                # If Flyway history exists, drop it to start fresh
                echo "üßπ Cleaning Flyway schema history if exists..."
                docker compose exec -e MYSQL_PWD="$MYSQL_ROOT_PASSWORD" mysql mysql -uroot -e "USE quizmakerdb; DROP TABLE IF EXISTS flyway_schema_history;" 2>/dev/null || echo "Cannot clean Flyway history"
                
                # Also clean any other Flyway-related tables
                echo "üßπ Cleaning all Flyway-related tables..."
                docker compose exec -e MYSQL_PWD="$MYSQL_ROOT_PASSWORD" mysql mysql -uroot -e "USE quizmakerdb; SHOW TABLES;" 2>/dev/null || echo "Cannot list tables"
                docker compose exec -e MYSQL_PWD="$MYSQL_ROOT_PASSWORD" mysql mysql -uroot -e "USE quizmakerdb; DROP DATABASE IF EXISTS quizmakerdb; CREATE DATABASE quizmakerdb CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;" 2>/dev/null || echo "Cannot recreate database"
                
                break
              fi
              
              # Show MySQL logs every 10 attempts
              if [ $((i % 10)) -eq 0 ]; then
                echo "üìã MySQL status (attempt $i/60):"
                docker compose ps mysql
                echo "üìã Recent MySQL logs:"
                docker compose logs --tail=10 mysql
              fi
              
              if [ $i -eq 60 ]; then
                echo "‚ùå MySQL failed to start after 2 minutes"
                echo "üìã Final MySQL logs:"
                docker compose logs mysql
                echo "üìã MySQL environment variables:"
                docker compose exec mysql env | grep MYSQL || true
                exit 1
              fi
              echo "‚è≥ MySQL not ready yet, waiting... ($i/60)"
              sleep 2
            done
            
            echo "üöÄ Starting backend service..."
            docker compose up -d quizmaker-backend
            
            # If backend fails due to Flyway issues, try to repair
            echo "üîß Checking if Flyway repair is needed..."
            sleep 5  # Give backend time to start and potentially fail
            
            if ! docker compose ps quizmaker-backend | grep -q "Up.*healthy"; then
              echo "‚ö†Ô∏è Backend not healthy, attempting Flyway repair..."
              
              # Try multiple Flyway repair approaches
              echo "üîß Running Flyway repair..."
              
              # Method 1: Try Maven Flyway repair (if Maven is available)
              if docker compose exec quizmaker-backend which mvn >/dev/null 2>&1; then
                echo "Using Maven Flyway repair..."
                docker compose exec quizmaker-backend mvn flyway:repair || echo "Maven Flyway repair failed"
              else
                echo "Maven not available, trying direct Flyway repair..."
                # Method 2: Try direct Flyway repair
                docker compose exec quizmaker-backend java -cp /app/app.jar org.flywaydb.commandline.Main repair || echo "Direct Flyway repair failed"
              fi
              
              # Method 3: Manual cleanup as fallback
              echo "Manual Flyway schema history cleanup as fallback..."
              docker compose exec -e MYSQL_PWD="$MYSQL_ROOT_PASSWORD" mysql mysql -uroot -e "USE quizmakerdb; DROP TABLE IF EXISTS flyway_schema_history;" 2>/dev/null || echo "Manual cleanup failed"
              
              # Restart backend after repair
              echo "üîÑ Restarting backend after Flyway repair..."
              docker compose restart quizmaker-backend
            else
              echo "‚úÖ Backend is healthy, no repair needed"
            fi
            
            echo "üìã Initial container status:"
            docker compose ps
            
            echo "üìã Environment variables check:"
            echo "DB_USERNAME: '${DB_USERNAME}'"
            db_password_length=$(printf '%s' "${DB_PASSWORD:-}" | wc -c)
            db_root_password_length=$(printf '%s' "${DB_ROOT_PASSWORD:-}" | wc -c)
            mysql_root_password_length=$(printf '%s' "${MYSQL_ROOT_PASSWORD:-}" | wc -c)
            echo "DB_PASSWORD: [HIDDEN - length: ${db_password_length}]"
            echo "DB_ROOT_PASSWORD: [HIDDEN - length: ${db_root_password_length}]"
            echo "MYSQL_ROOT_PASSWORD: [HIDDEN - length: ${mysql_root_password_length}]"
            
            echo "üîç Debug: Docker Compose environment variable resolution:"
            docker compose config | grep -A 20 -B 5 "SPRING_DATASOURCE_USERNAME\|MYSQL_USER" || true
            
            echo "‚è≥ Waiting for backend to be ready..."
            # Wait for backend to be healthy
            for i in {1..30}; do
              if curl -f http://localhost:8080/actuator/health > /dev/null 2>&1; then
                echo "‚úÖ Backend is ready!"
                break
              fi
              
              if [ $i -eq 30 ]; then
                echo "‚ùå Backend failed to start"
                echo "üìã Container status:"
                docker compose ps
                echo "üìã Backend logs:"
                docker compose logs --tail=50 quizmaker-backend
                exit 1
              fi
              echo "‚è≥ Backend not ready yet, waiting... ($i/30)"
              sleep 5
            done
            
            echo "‚úÖ Backend containers started"

      - name: Wait for backend to be healthy
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          script: |
            set -e
            cd /var/www/quizmaker-backend
            
            # Load environment variables from .env file
            set -a
            if ! source .env 2>/dev/null; then
              echo "‚ö†Ô∏è Warning: Failed to load .env file for health check step."
            fi
            set +a
            
            echo "‚è≥ Waiting for backend to be healthy..."
            
            # Wait up to 5 minutes for the backend to be healthy
            for i in {1..60}; do
              if curl -f http://localhost:8080/actuator/health > /dev/null 2>&1; then
                echo "‚úÖ Backend is healthy!"
                break
              fi
              
              if [ $i -eq 60 ]; then
                echo "‚ùå Backend health check timeout"
                echo "üìã Container status:"
                docker compose ps
                echo "üìã Backend logs:"
                docker compose logs --tail=50 quizmaker-backend
                echo "üìã MySQL logs:"
                docker compose logs --tail=50 mysql
                exit 1
              fi
              
              echo "‚è≥ Attempt $i/60: Backend not ready yet, waiting..."
              sleep 5
            done
            
            echo "üéâ Backend deployment completed successfully!"
            
            # Show final status
            echo "üìä Final container status:"
            docker compose ps
            
            echo "üåê Backend should be available at:"
            echo "   - Health: https://quizzence.com/actuator/health"
            echo "   - API Docs: https://quizzence.com/api/v1/docs/swagger-ui.html"

      - name: Cleanup deployment files
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          script: |
            cd /var/www/quizmaker-backend
            
            # Load environment variables if .env exists
            if [ -f .env ]; then
              echo "üîç Attempting to load existing environment variables during cleanup (non-fatal if parsing fails)..."
              set -a
              if ! source .env 2>/dev/null; then
                echo "‚ö†Ô∏è Warning: Failed to parse existing .env file during cleanup."
              fi
              set +a
            fi
            
            # Clean up old Docker images to save space
            docker image prune -f || true
            echo "‚úÖ Cleanup completed"
