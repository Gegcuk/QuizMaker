name: Deploy Backend to Production

on:
  push:
    branches: [ master, main ]
    paths:
      - 'src/**'
      - 'pom.xml'
      - 'server/backend/**'
      - '.github/workflows/deploy-backend.yml'

jobs:
  deploy-backend:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'
          cache: maven

      - name: Build application
        run: |
          ./mvnw clean package -DskipTests -B
          echo "‚úÖ Application built successfully"

      - name: Prepare deployment bundle
        run: |
          rm -rf deployment && mkdir -p deployment
          
          # Copy backend deployment files
          cp -r server/backend/* deployment/
          
          # Copy application files (target/ not needed as Dockerfile rebuilds from source)
          cp pom.xml deployment/
          cp -r src deployment/
          
          # Create production properties
          cp server/backend/application-prod.properties deployment/src/main/resources/
          
          echo "üîç Debug: Checking deployment bundle contents:"
          ls -la deployment/ || echo "Deployment directory not found"
          echo "üîç Debug: Checking if mysql-init directory was copied:"
          ls -la deployment/mysql-init/ || echo "mysql-init directory not found in deployment"
          
          echo "‚úÖ Deployment bundle prepared"

      - name: Stop old backend (ignore if first run)
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          script: |
            set -e
            mkdir -p /var/www/quizmaker-backend
            cd /var/www/quizmaker-backend
            
            # Load environment variables if .env exists
            if [ -f .env ]; then
              echo "üîç Attempting to load existing environment variables (non-fatal if parsing fails)..."
              set -a
              if ! source .env 2>/dev/null; then
                echo "‚ö†Ô∏è Warning: Failed to parse existing .env file. Continuing without exporting variables."
              fi
              set +a
            fi
            
            # Stop existing containers
            docker compose down || true
            
            # Clean up old images to save space
            docker image prune -f || true
            
            echo "‚úÖ Old backend stopped"

      - name: Copy deployment files
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          source: "deployment/*"
          target: "/var/www/quizmaker-backend/"
          strip_components: 1
          overwrite: true

      - name: Create environment file and deploy
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          script: |
            set -e
            cd /var/www/quizmaker-backend
            
            # Create .env file from secrets
            cat > .env <<'EOF'
            # Database Configuration
            DB_USERNAME="${{ secrets.DB_PROD_USERNAME || 'quizmaker_user' }}"
            DB_PASSWORD="${{ secrets.DB_PASSWORD }}"
            DB_ROOT_PASSWORD="${{ secrets.DB_ROOT_PASSWORD }}"
            MYSQL_ROOT_PASSWORD="${{ secrets.DB_ROOT_PASSWORD }}"
            # Debug: show full secrets from init script (set to 0 after debugging)
            MYSQL_INIT_SHOW_SECRETS="1"
            
            # JWT Configuration
            JWT_SECRET="${{ secrets.JWT_SECRET }}"
            
            # Security Peppers
            TOKEN_PEPPER_SECRET="${{ secrets.TOKEN_PEPPER_SECRET }}"
            RESET_TOKEN_PEPPER="${{ secrets.RESET_TOKEN_PEPPER }}"
            VERIFICATION_TOKEN_PEPPER="${{ secrets.VERIFICATION_TOKEN_PEPPER }}"
            
            # OpenAI Configuration
            OPENAI_API_KEY="${{ secrets.OPENAI_API_KEY }}"
            OPENAI_MODEL="${{ secrets.OPENAI_MODEL }}"
            
            # Stripe Configuration
            STRIPE_SECRET_KEY="${{ secrets.STRIPE_SECRET_KEY }}"
            STRIPE_WEBHOOK_SECRET="${{ secrets.STRIPE_WEBHOOK_SECRET }}"
            STRIPE_PUBLISHABLE_KEY="${{ secrets.STRIPE_PUBLISHABLE_KEY }}"
            STRIPE_PRICE_SMALL="${{ secrets.STRIPE_PRICE_SMALL }}"
            STRIPE_PRICE_MEDIUM="${{ secrets.STRIPE_PRICE_MEDIUM }}"
            STRIPE_PRICE_LARGE="${{ secrets.STRIPE_PRICE_LARGE }}"
            STRIPE_PRICE_SUBSCRIPTION="${{ secrets.STRIPE_PRICE_SUBSCRIPTION }}"
            
            # Email Configuration
            SMTP_HOST="${{ secrets.SMTP_HOST }}"
            SMTP_PORT="${{ secrets.SMTP_PORT }}"
            SMTP_USERNAME="${{ secrets.SMTP_USERNAME }}"
            SMTP_PASSWORD="${{ secrets.SMTP_PASSWORD }}"
            
            # Frontend Configuration
            FRONTEND_BASE_URL="${{ secrets.FRONTEND_BASE_URL }}"
            
            # Billing Configuration (optional)
            BILLING_TOKEN_TO_LLM_RATIO="${{ secrets.BILLING_TOKEN_TO_LLM_RATIO || '1.0' }}"
            BILLING_RESERVATION_TTL_MINUTES="${{ secrets.BILLING_RESERVATION_TTL_MINUTES || '30' }}"
            BILLING_SAFETY_FACTOR="${{ secrets.BILLING_SAFETY_FACTOR || '1.2' }}"
            BILLING_CURRENCY="${{ secrets.BILLING_CURRENCY || 'USD' }}"
            EOF
            
            # Verify .env file was created successfully
            if [ ! -f .env ]; then
              echo "‚ùå Failed to create .env file!"
              exit 1
            fi
            
            # Set proper permissions
            chmod 600 .env
            
            # Verify .env file is readable and has content
            if [ ! -s .env ]; then
              echo "‚ùå .env file is empty!"
              exit 1
            fi
            
            # Make MySQL init scripts executable
            chmod +x mysql-init/*.sh 2>/dev/null || true
            
            echo "üîç Debug: MySQL init scripts status:"
            ls -la mysql-init/ || echo "mysql-init directory not found"
            echo "üîç Debug: Checking if init scripts are executable:"
            find mysql-init/ -name "*.sh" -exec ls -la {} \; || echo "No .sh files found"
            echo "üîç Debug: Checking all files in mysql-init directory:"
            find mysql-init/ -type f -exec ls -la {} \; 2>/dev/null || echo "mysql-init directory not accessible"
            
            echo "‚úÖ Environment file created"
            echo "üìã Environment file structure (without sensitive values):"
            grep -E "^[A-Z_]+=.*" .env | sed 's/=.*/=[HIDDEN]/' || true
            
            echo "üîç Debug: Checking specific variables:"
            db_username_length=$(printf '%s' "${DB_USERNAME:-}" | wc -c)
            db_password_length=$(printf '%s' "${DB_PASSWORD:-}" | wc -c)
            db_root_password_length=$(printf '%s' "${DB_ROOT_PASSWORD:-}" | wc -c)
            echo "DB_USERNAME length: ${db_username_length}"
            echo "DB_PASSWORD length: ${db_password_length}"
            echo "DB_ROOT_PASSWORD length: ${db_root_password_length}"
            echo "DB_USERNAME value: '$DB_USERNAME'"
            echo "DB_PASSWORD first 3 chars: '$(echo "$DB_PASSWORD" | cut -c1-3)...'"
            echo "DB_ROOT_PASSWORD first 3 chars: '$(echo "$DB_ROOT_PASSWORD" | cut -c1-3)...'"
            
            echo "üîç Debug: Environment file contents (sanitized):"
            cat .env | sed 's/=.*/=[REDACTED]/' | head -10
            
            echo "üîç Debug: Checking if .env file exists and is readable:"
            ls -la .env || echo "‚ùå .env file not found!"
            
            echo "üîç Debug: First 5 lines of .env file:"
            head -5 .env || echo "‚ùå Cannot read .env file!"
            
            echo "üîç Debug: Loading .env file and checking variables:"
            set -a
            if ! source .env 2>/dev/null; then
              echo "‚ö†Ô∏è Warning: Failed to load .env file for debugging output."
            fi
            set +a
            echo "After loading .env:"
            echo "DB_USERNAME: '${DB_USERNAME:-NOT_SET}'"
            db_password_length=$(printf '%s' "${DB_PASSWORD:-}" | wc -c)
            db_root_password_length=$(printf '%s' "${DB_ROOT_PASSWORD:-}" | wc -c)
            echo "DB_PASSWORD length: ${db_password_length}"
            echo "DB_ROOT_PASSWORD length: ${db_root_password_length}"

      - name: Build and start backend
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          script: |
            set -e
            cd /var/www/quizmaker-backend
            
            # Check if .env file exists first
            echo "üîç Checking if .env file exists..."
            if [ ! -f .env ]; then
              echo "‚ùå .env file does not exist! Cannot proceed."
              echo "üìã Current directory contents:"
              ls -la
              exit 1
            fi
            
            echo "‚úÖ .env file exists. Checking its contents..."
            echo "üìã .env file size: $(wc -c < .env) bytes"
            echo "üìã .env file line count: $(wc -l < .env) lines"
            echo "üìã First 10 lines of .env file:"
            head -10 .env || echo "Cannot read .env file"
            
            # Load environment variables from .env file
            echo "üîç Loading environment variables from .env file..."
            sed -i 's/\r$//' .env

            # Try to load with verbose error output first
            echo "üîç Attempting to source .env file with verbose output:"
            if ! source .env; then
              echo "‚ùå Failed to source .env file. Checking for specific issues..."
              
              # Check for problematic characters
              echo "üìã Checking for non-printable characters:"
              hexdump -C .env | head -10
              
              # Check for specific problematic patterns
              echo "üìã Checking for problematic patterns:"
              grep -n '[[:space:]]$' .env || echo "No trailing whitespace found"
              grep -n '^[[:space:]]' .env || echo "No leading whitespace found"
              grep -n '=' .env | head -5 || echo "No equals signs found"
              
              # Try loading line by line to find the problematic line
              echo "üìã Testing .env file line by line:"
              line_num=0
              while IFS= read -r line; do
                line_num=$((line_num + 1))
                if [[ "$line" =~ ^[[:space:]]*# ]] || [[ -z "$line" ]]; then
                  echo "Line $line_num: OK (comment/empty): $line"
                elif [[ "$line" =~ ^[A-Z_]+= ]]; then
                  echo "Line $line_num: OK (variable): ${line%%=*}=[HIDDEN]"
                else
                  echo "Line $line_num: PROBLEMATIC: '$line'"
                  break
                fi
              done < .env
              
              exit 1
            fi

            echo "‚úÖ Successfully loaded .env file"
            
            if [ -z "${MYSQL_ROOT_PASSWORD:-}" ] && [ -n "${DB_ROOT_PASSWORD:-}" ]; then
              export MYSQL_ROOT_PASSWORD="${DB_ROOT_PASSWORD}"
              echo "‚ÑπÔ∏è  MYSQL_ROOT_PASSWORD not provided. Falling back to DB_ROOT_PASSWORD."
            fi

            if [ -z "${MYSQL_ROOT_PASSWORD:-}" ]; then
              echo "‚ùå MYSQL_ROOT_PASSWORD is required but not set."
              exit 1
            fi

            echo "üîç Environment variables loaded:"
            echo "DB_USERNAME: '${DB_USERNAME:-NOT_SET}'"
            db_password_length=$(printf '%s' "${DB_PASSWORD:-}" | wc -c)
            db_root_password_length=$(printf '%s' "${DB_ROOT_PASSWORD:-}" | wc -c)
            mysql_root_password_length=$(printf '%s' "${MYSQL_ROOT_PASSWORD:-}" | wc -c)
            echo "DB_PASSWORD length: ${db_password_length}"
            echo "DB_ROOT_PASSWORD length: ${db_root_password_length}"
            echo "MYSQL_ROOT_PASSWORD length: ${mysql_root_password_length}"
            
            # Verify docker-compose.yml syntax
            echo "üîç Verifying Docker Compose configuration..."
            docker compose config --quiet
            
            # Build and start services
            echo "üî® Building backend container..."
            docker compose build --no-cache
            
            echo "üßπ PHASE 2: Clearing MySQL data volume for proper Flyway migration..."
            docker compose down -v || true
            docker volume rm quizmaker-backend_mysql_data || true
            
            # PHASE 2: Clean database state for proper Flyway migration with indexes
            echo "üßπ PHASE 2: Ensuring clean database state for Flyway migration..."
            
            # Stop all containers first
            echo "üõë Stopping all containers..."
            docker compose down -v || true
            
            # Remove the specific MySQL data volume
            echo "üóëÔ∏è Removing MySQL data volume..."
            docker volume rm quizmaker-backend_mysql_data 2>/dev/null || true
            docker volume rm quizmaker-backend_uploads_data 2>/dev/null || true
            
            # Force remove any lingering volumes
            docker volume prune -f || true
            
            # Remove any existing containers
            echo "üóëÔ∏è Removing existing containers..."
            docker compose rm -f || true
            
            echo "üöÄ Starting MySQL first..."
            docker compose up -d mysql
            
            echo "[STEP 1] ‚è≥ Waiting for MySQL to be ready before starting backend..."
            # Wait for MySQL to be healthy before starting backend
            for i in {1..60}; do
              if docker compose exec -e MYSQL_PWD="$MYSQL_ROOT_PASSWORD" mysql mysqladmin ping -h localhost -u root --silent 2>/dev/null; then
                echo "[STEP 2] ‚úÖ MySQL is ready!"
                
                # Extra: wait for transition from temporary (port: 0) to final server
                echo "[STEP 2A] üîé Waiting for MySQL to switch from temporary to final server..."
                seen_temp=0
                for k in {1..60}; do
                  logs=$(docker compose logs --no-color --tail=200 mysql 2>/dev/null || true)
                  if printf "%s" "$logs" | grep -qE "\\[Entrypoint\\]: Temporary server started"; then
                    seen_temp=1
                  fi
                  # Final server usually logs ready with non-zero port OR init process done
                  if printf "%s" "$logs" | grep -qE "ready for connections.*port: [1-9][0-9]*" || \
                     printf "%s" "$logs" | grep -qE "\\[Entrypoint\\]: MySQL init process done\\. Ready for start up\.|\\[Entrypoint\\]: Starting MySQL"; then
                    echo "[STEP 2A] ‚úÖ Final server readiness detected"
                    break
                  fi
                  if [ $k -eq 60 ]; then
                    echo "[STEP 2A] ‚ö†Ô∏è Did not conclusively detect final switch; continuing"
                    break
                  fi
                  sleep 2
                done
                
                # Check if init scripts were copied and are executable
                echo "[STEP 3] üîç Checking MySQL init scripts in container..."
                docker compose exec mysql ls -la /docker-entrypoint-initdb.d/ || echo "Cannot access init directory"
                
                # Check MySQL initialization logs
                echo "[STEP 4] üîç Checking MySQL initialization logs..."
                docker compose logs mysql | grep -Ei "\[mysql-init\]|DEBUG:|ERROR:|initdb|Entrypoint" || echo "No init logs found"
                
                # Check MySQL container environment variables
                echo "[STEP 5] üîç Checking MySQL container environment variables..."
                docker compose exec mysql env | grep MYSQL || echo "No MYSQL environment variables found"
                
                echo "[STEP 6] üîç Verifying MySQL root connectivity and initialization..."
                echo "[STEP 6] Credentials preview (unmasked as requested):"
                echo "  DB_USERNAME='$DB_USERNAME'"
                echo "  DB_PASSWORD='$DB_PASSWORD'"
                echo "  DB_ROOT_PASSWORD='$DB_ROOT_PASSWORD'"
                echo "  MYSQL_ROOT_PASSWORD='$MYSQL_ROOT_PASSWORD'"
                # Try a few times in case entrypoint is switching from temp to final server
                root_ok=0; for j in 1 2 3 4 5; do
                  if docker compose exec -e MYSQL_PWD="$MYSQL_ROOT_PASSWORD" mysql mysql -uroot -e "SELECT 1;" >/dev/null 2>&1; then root_ok=1; break; fi
                  echo "[STEP 6] Root connection not ready yet (attempt $j/5), sleeping 2s..."; sleep 2; done
                if [ "$root_ok" -ne 1 ]; then
                  echo "‚ùå Could not connect as root with provided password. Aborting to avoid racing entrypoint."
                  docker compose logs --tail=50 mysql || true
                  exit 1
                fi
                echo "[STEP 6] ‚úÖ Root connection verified"
                
                # Check MySQL users after initialization
                echo "[STEP 7] üîç Checking MySQL users after initialization..."
                docker compose exec -e MYSQL_PWD="$MYSQL_ROOT_PASSWORD" mysql mysql -uroot -e "SELECT User, Host FROM mysql.user WHERE User NOT IN ('mysql.session', 'mysql.sys', 'mysql.infoschema', '');" 2>/dev/null || echo "Could not check users"
                
                # Verify application user exists with % host
                app_user_check=$(docker compose exec -e MYSQL_PWD="$MYSQL_ROOT_PASSWORD" mysql mysql -uroot -N -B -e "SELECT COUNT(*) FROM mysql.user WHERE User='$DB_USERNAME' AND Host='%';" 2>/dev/null | tr -d '\r' || echo "0")
                
                if [ "$app_user_check" = "0" ]; then
                  echo "[STEP 8] ‚ö†Ô∏è Application user '$DB_USERNAME' not found with % host access!"
                  echo "[STEP 8] üîß Creating application user manually..."
                  docker compose exec -e MYSQL_PWD="$MYSQL_ROOT_PASSWORD" mysql mysql -uroot -e "
                    CREATE DATABASE IF NOT EXISTS \`quizmakerdb\` CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
                    CREATE USER IF NOT EXISTS '$DB_USERNAME'@'%' IDENTIFIED BY '$DB_PASSWORD';
                    GRANT ALL PRIVILEGES ON \`quizmakerdb\`.* TO '$DB_USERNAME'@'%';
                    FLUSH PRIVILEGES;
                  " || echo "Manual user creation failed"
                  
                  # Verify again
                  app_user_check=$(docker compose exec -e MYSQL_PWD="$MYSQL_ROOT_PASSWORD" mysql mysql -uroot -N -B -e "SELECT COUNT(*) FROM mysql.user WHERE User='$DB_USERNAME' AND Host='%';" 2>/dev/null | tr -d '\r' || echo "0")
                  if [ "$app_user_check" = "0" ]; then
                    echo "‚ùå Failed to create application user. Aborting deployment."
                    exit 1
                  else
                    echo "‚úÖ Application user created successfully!"
                  fi
                else
                  echo "[STEP 8] ‚úÖ Application user '$DB_USERNAME' found with % host access!"
                fi
                
                 # Clean Flyway schema history for fresh start
                 echo "[STEP 9] üßπ Cleaning Flyway schema history for fresh start..."
                 
                 # First, check if the database exists and what's in it
                 echo "[STEP 9A] üîç Checking current database state..."
                 docker compose exec -e MYSQL_PWD="$MYSQL_ROOT_PASSWORD" mysql mysql -uroot -e "SHOW DATABASES LIKE 'quizmakerdb';" 2>/dev/null || echo "Cannot check databases"
                 
                 # Drop the entire database and recreate it to ensure clean state
                 echo "[STEP 9B] üóëÔ∏è Dropping quizmakerdb database..."
                 docker compose exec -e MYSQL_PWD="$MYSQL_ROOT_PASSWORD" mysql mysql -uroot -e "DROP DATABASE IF EXISTS quizmakerdb;" 2>/dev/null || echo "Cannot drop database"
                 
                 # Verify database was dropped
                 echo "[STEP 9C] üîç Verifying database was dropped..."
                 docker compose exec -e MYSQL_PWD="$MYSQL_ROOT_PASSWORD" mysql mysql -uroot -e "SHOW DATABASES LIKE 'quizmakerdb';" 2>/dev/null || echo "Cannot check databases"
                 
                 # Recreate the database
                 echo "[STEP 9D] üèóÔ∏è Creating fresh quizmakerdb database..."
                 docker compose exec -e MYSQL_PWD="$MYSQL_ROOT_PASSWORD" mysql mysql -uroot -e "CREATE DATABASE quizmakerdb CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;" 2>/dev/null || echo "Cannot create database"
                 
                 # Verify database was created
                 echo "[STEP 9E] üîç Verifying fresh database was created..."
                 docker compose exec -e MYSQL_PWD="$MYSQL_ROOT_PASSWORD" mysql mysql -uroot -e "SHOW DATABASES LIKE 'quizmakerdb';" 2>/dev/null || echo "Cannot check databases"
                 
                 echo "[STEP 9] ‚úÖ Database recreated cleanly for Flyway"
                 
                 # Additional step: Manually clean any Flyway schema history that might persist
                 echo "[STEP 9F] üßπ Manually cleaning any remaining Flyway schema history..."
                 docker compose exec -e MYSQL_PWD="$MYSQL_ROOT_PASSWORD" mysql mysql -uroot -e "DROP TABLE IF EXISTS quizmakerdb.flyway_schema_history;" 2>/dev/null || echo "No flyway_schema_history table to drop"
                 docker compose exec -e MYSQL_PWD="$MYSQL_ROOT_PASSWORD" mysql mysql -uroot -e "DROP SCHEMA IF EXISTS flyway_schema_history;" 2>/dev/null || echo "No flyway_schema_history schema to drop"
                 
                 echo "[STEP 9F] ‚úÖ Flyway schema history manually cleaned"
                
                break
              fi
              
              # Show MySQL logs every 10 attempts
              if [ $((i % 10)) -eq 0 ]; then
                echo "üìã MySQL status (attempt $i/60):"
                docker compose ps mysql
                echo "üìã Recent MySQL logs:"
                docker compose logs --tail=10 mysql
              fi
              
              if [ $i -eq 60 ]; then
                echo "‚ùå MySQL failed to start after 2 minutes"
                echo "üìã Final MySQL logs:"
                docker compose logs mysql
                echo "üìã MySQL environment variables:"
                docker compose exec mysql env | grep MYSQL || true
                exit 1
              fi
              echo "‚è≥ MySQL not ready yet, waiting... ($i/60)"
              sleep 2
            done
            
            echo "[STEP 10] üöÄ Starting backend service..."
            docker compose up -d quizmaker-backend
            
            # If backend fails due to Flyway issues, try to repair
            echo "[STEP 11] üîß Checking if Flyway repair is needed..."
            sleep 5  # Give backend time to start and potentially fail
            
            if ! docker compose ps quizmaker-backend | grep -q "Up.*healthy"; then
              echo "‚ö†Ô∏è Backend not healthy. Skipping Flyway CLI repair (not available)."
              echo "üìã Backend logs (last 200 lines):"
              docker compose logs --tail=200 quizmaker-backend || true
              echo "üìã MySQL logs (last 200 lines):"
              docker compose logs --tail=200 mysql || true
              echo "üìã Inspecting Flyway schema history for error details..."
              if docker compose exec -e MYSQL_PWD="$MYSQL_ROOT_PASSWORD" mysql mysql -uroot -N -B -e "SELECT 1 FROM information_schema.tables WHERE table_schema='quizmakerdb' AND table_name='flyway_schema_history';" | grep -q 1; then
                docker compose exec -e MYSQL_PWD="$MYSQL_ROOT_PASSWORD" mysql mysql -uroot -N -B -e "\
                  SELECT installed_rank, version, description, type, script, checksum, installed_by, success, COALESCE(error_message,'') \
                  FROM quizmakerdb.flyway_schema_history ORDER BY installed_rank;" || true
              else
                echo "(No flyway_schema_history table found in quizmakerdb)"
              fi
              echo "üîÑ Restarting backend once to retry..."
              docker compose restart quizmaker-backend || true
            else
              echo "‚úÖ Backend is healthy, no repair needed"
            fi
            
            echo "üìã Initial container status:"
            docker compose ps
            
            echo "üìã Environment variables check:"
            echo "DB_USERNAME: '${DB_USERNAME}'"
            db_password_length=$(printf '%s' "${DB_PASSWORD:-}" | wc -c)
            db_root_password_length=$(printf '%s' "${DB_ROOT_PASSWORD:-}" | wc -c)
            mysql_root_password_length=$(printf '%s' "${MYSQL_ROOT_PASSWORD:-}" | wc -c)
            echo "DB_PASSWORD: [HIDDEN - length: ${db_password_length}]"
            echo "DB_ROOT_PASSWORD: [HIDDEN - length: ${db_root_password_length}]"
            echo "MYSQL_ROOT_PASSWORD: [HIDDEN - length: ${mysql_root_password_length}]"
            
            echo "üîç Debug: Docker Compose environment variable resolution:"
            docker compose config | grep -A 20 -B 5 "SPRING_DATASOURCE_USERNAME\|MYSQL_USER" || true
            
            echo "‚è≥ Waiting for backend to be ready..."
            # Wait for backend to be healthy
            for i in {1..30}; do
              if curl -f http://localhost:8080/actuator/health > /dev/null 2>&1; then
                echo "‚úÖ Backend is ready!"
                break
              fi
              
              if [ $i -eq 30 ]; then
                echo "‚ùå Backend failed to start"
                echo "üìã Container status:"
                docker compose ps
                echo "üìã Backend logs:"
                docker compose logs --tail=50 quizmaker-backend
                exit 1
              fi
              echo "‚è≥ Backend not ready yet, waiting... ($i/30)"
              sleep 5
            done
            
            echo "‚úÖ Backend containers started"

      - name: Wait for backend to be healthy
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          script: |
            set -e
            cd /var/www/quizmaker-backend
            
            # Load environment variables from .env file
            set -a
            if ! source .env 2>/dev/null; then
              echo "‚ö†Ô∏è Warning: Failed to load .env file for health check step."
            fi
            set +a
            
            echo "‚è≥ Waiting for backend to be healthy..."
            
            # Wait up to 5 minutes for the backend to be healthy
            for i in {1..60}; do
              if curl -f http://localhost:8080/actuator/health > /dev/null 2>&1; then
                echo "‚úÖ Backend is healthy!"
                break
              fi
              
              if [ $i -eq 60 ]; then
                echo "‚ùå Backend health check timeout"
                echo "üìã Container status:"
                docker compose ps
                echo "üìã Backend logs:"
                docker compose logs --tail=50 quizmaker-backend
                echo "üìã MySQL logs:"
                docker compose logs --tail=50 mysql
                exit 1
              fi
              
              echo "‚è≥ Attempt $i/60: Backend not ready yet, waiting..."
              sleep 5
            done
            
            echo "üéâ Backend deployment completed successfully!"
            
            # Show final status
            echo "üìä Final container status:"
            docker compose ps
            
            echo "üåê Backend should be available at:"
            echo "   - Health: https://quizzence.com/actuator/health"
            echo "   - API Docs: https://quizzence.com/api/v1/docs/swagger-ui.html"

      - name: Cleanup deployment files
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          script: |
            cd /var/www/quizmaker-backend
            
            # Load environment variables if .env exists
            if [ -f .env ]; then
              echo "üîç Attempting to load existing environment variables during cleanup (non-fatal if parsing fails)..."
              set -a
              if ! source .env 2>/dev/null; then
                echo "‚ö†Ô∏è Warning: Failed to parse existing .env file during cleanup."
              fi
              set +a
            fi
            
            # Clean up old Docker images to save space
            docker image prune -f || true
            echo "‚úÖ Cleanup completed"
